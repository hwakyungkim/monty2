<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ï°∞Í±¥Î∂ÄÌôïÎ•† ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
:root {
  --background-color: #121212;
  --text-color: #e0e0e0;
  --door-color: #4a4a4a;
  --door-border-color: #2a2a2a;
  --door-selected-color: #f39c12;
  --button-bg-color: #3498db;
  --button-hover-bg-color: #2980b9;
  --section-bg-color: #1e1e1e;
  --win-color: #2ecc71;
  --loss-color: #e74c3c;
  --reset-button-bg-color: #e74c3c;
  --reset-button-hover-bg-color: #c0392b;
}

body {
  font-family: 'Noto Sans KR', sans-serif;
  background-color: var(--background-color);
  color: var(--text-color);
  margin: 0;
  padding: 20px;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
  box-sizing: border-box;
}

#root {
  width: 100%;
  max-width: 800px;
  text-align: center;
}

#app {
  position: relative;
}

h1 {
  font-size: 2.5rem;
  color: var(--text-color);
  margin-bottom: 2rem;
}

hr {
  border: none;
  border-top: 1px solid var(--door-border-color);
  margin: 3rem 0;
}

.section-card {
  background-color: var(--section-bg-color);
  padding: 25px;
  border-radius: 12px;
  border: 1px solid var(--door-border-color);
  margin-bottom: 2rem;
}

.section-card h2 {
  margin-top: 0;
  color: var(--door-selected-color);
}


/* --- Settings Panel --- */
.settings-panel p {
    margin-bottom: 1.5rem;
}

.apply-settings-button {
    margin-top: 1rem;
}

/* --- Manual Simulator --- */

.doors-container {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 20px;
  margin: 2rem 0;
  perspective: 1000px;
}

.door {
  width: 100px;
  height: 150px;
  cursor: pointer;
  position: relative;
  transform-style: preserve-3d;
  transition: transform 0.8s;
  flex-shrink: 0;
}

.door.open {
  transform: rotateY(180deg);
  cursor: default;
}

.door-front, .door-back {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 10px;
  border: 3px solid var(--door-border-color);
  overflow: hidden;
}

.door-front {
  background-color: var(--door-color);
  color: var(--text-color);
  font-size: 3rem;
  font-weight: bold;
}

.door.selected .door-front {
  border-color: var(--door-selected-color);
  box-shadow: 0 0 15px var(--door-selected-color);
}

.door-back {
  background-color: #2c2c2c;
  transform: rotateY(180deg);
}

.door-content {
  font-size: 4.5rem; /* Increased size */
  line-height: 1;
}

.game-message {
  font-size: 1.2rem;
  min-height: 2rem;
  margin-bottom: 1rem;
  color: var(--text-color);
}

.manual-controls button {
  margin: 0.5rem;
}

.manual-stats {
  margin-top: 1.5rem;
  font-size: 0.9rem;
  color: #aaa;
}
.manual-stats p {
  margin: 4px 0;
  min-height: auto;
}

/* --- Auto Simulator --- */

.config-panel {
  padding: 10px 0;
  margin-bottom: 1rem;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 20px;
  align-items: flex-end;
}

.config-item {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 5px;
}

.config-item.wide {
  grid-column: 1 / -1;
}

.config-item label {
  font-size: 0.9rem;
  color: #ccc;
  font-weight: 500;
}

.config-item input {
  background-color: var(--door-color);
  color: var(--text-color);
  border: 2px solid var(--door-border-color);
  border-radius: 5px;
  padding: 8px;
  font-size: 1rem;
  width: 100%;
  box-sizing: border-box;
  transition: border-color 0.3s, box-shadow 0.3s;
}

.config-item input[type="range"] {
  padding: 0;
}

.config-item input:focus {
  outline: none;
  border-color: var(--button-bg-color);
  box-shadow: 0 0 5px var(--button-bg-color);
}

.simulation-controls {
  margin-bottom: 2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
}

.error-message {
  color: var(--loss-color);
  font-size: 0.9rem;
  min-height: 1.4rem;
  font-weight: 500;
  margin-top: 1rem;
}

progress {
  width: 100%;
  max-width: 400px;
  height: 12px;
  -webkit-appearance: none;
  appearance: none;
  border: none;
  border-radius: 10px;
  overflow: hidden;
  margin-top: 1rem;
}

progress::-webkit-progress-bar {
  background-color: #333;
}

progress::-webkit-progress-value {
  background-color: var(--win-color);
  transition: width 0.1s linear;
}

button {
  background-color: var(--button-bg-color);
  color: white;
  border: none;
  padding: 12px 24px;
  font-size: 1rem;
  font-weight: bold;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.2s ease;
}

button:hover:not(:disabled) {
  background-color: var(--button-hover-bg-color);
  transform: translateY(-2px);
}

button:disabled {
  background-color: #7f8c8d;
  cursor: not-allowed;
  transform: none;
}

.stop-button {
  background-color: var(--loss-color);
}
.stop-button:hover:not(:disabled) {
  background-color: #c0392b;
}


.stats-container {
  padding: 10px 0;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-top: 1rem;
}

.stats-box {
  background-color: #2c2c2c;
  padding: 20px;
  border-radius: 8px;
}

.stats-box h3 {
  margin-top: 0;
  margin-bottom: 15px;
  color: var(--door-selected-color);
  font-size: 1.5rem;
}

.stats-box p {
  margin: 8px 0;
  font-size: 1rem;
  min-height: auto;
}

.win {
  color: var(--win-color);
  font-weight: bold;
  font-size: 1.2rem;
}

.animation-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  justify-content: center;
  margin-bottom: 1.5rem;
  padding: 10px;
  background-color: #111;
  border-radius: 5px;
  max-height: 200px;
  overflow-y: auto;
}

.anim-door {
  width: 12px;
  height: 12px;
  background-color: var(--door-color);
  border-radius: 2px;
  transition: background-color 0.2s ease;
}

.anim-door.win {
  background-color: var(--win-color);
}
.anim-door.loss {
  background-color: var(--loss-color);
}


@media (max-width: 600px) {
  h1 {
    font-size: 2rem;
  }
  .config-panel {
    grid-template-columns: 1fr;
  }
  .stats-container {
    grid-template-columns: 1fr;
  }
}
    </style>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.1.1",
    "react-dom/client": "https://esm.sh/react-dom@19.1.1/client",
    "react-dom/": "https://esm.sh/react-dom@^19.1.1/",
    "react/": "https://esm.sh/react@^19.1.1/"
  }
}
</script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>
    <script type="text/babel" data-presets="react,typescript" data-type="module">
        import React, { useState, useEffect, useCallback, useRef } from 'react';
        import { createRoot } from 'react-dom/client';

        // --- Interfaces ---

        interface DoorState {
          hasPrize: boolean;
          isOpen: boolean;
          isSelected: boolean;
        }

        interface Stats {
          wins: number;
          losses: number;
        }

        interface SimulatorConfig {
          numberOfDoors: number;
          numberOfPrizes: number;
        }

        // --- Constants ---
        const CAR_EMOJI = 'üöó';
        const GOAT_EMOJI = 'üêê';

        // --- Helper Functions ---
        const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

        // --- Components ---

        const Door: React.FC<{ door: DoorState; onClick: () => void; doorNumber: number }> = ({ door, onClick, doorNumber }) => (
          <div className={`door ${door.isOpen ? 'open' : ''} ${door.isSelected ? 'selected' : ''}`} onClick={onClick}>
            <div className="door-front">{doorNumber}</div>
            <div className="door-back">
              <span className="door-content">
                {door.hasPrize ? CAR_EMOJI : GOAT_EMOJI}
              </span>
            </div>
          </div>
        );

        const Simulator: React.FC<{ config: SimulatorConfig }> = ({ config }) => {
          const { numberOfDoors, numberOfPrizes } = config;
          
          const setupDoors = useCallback((): DoorState[] => {
            const doors: DoorState[] = Array(numberOfDoors).fill(null).map(() => ({ hasPrize: false, isOpen: false, isSelected: false }));
            let prizesPlaced = 0;
            while (prizesPlaced < numberOfPrizes) {
              const position = Math.floor(Math.random() * numberOfDoors);
              if (!doors[position].hasPrize) {
                doors[position].hasPrize = true;
                prizesPlaced++;
              }
            }
            return doors;
          }, [numberOfDoors, numberOfPrizes]);

          // --- State ---
          const [doors, setDoors] = useState<DoorState[]>(() => setupDoors());
          const [gameState, setGameState] = useState<'initial' | 'picked' | 'revealed' | 'finished'>('initial');
          const [message, setMessage] = useState(`${numberOfDoors}Í∞úÏùò Î¨∏ Ï§ë ÌïòÎÇòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.`);
          const [manualStats, setManualStats] = useState({ stayWins: 0, switchWins: 0, total: 0 });

          const [simulations, setSimulations] = useState(1000);
          const [speed, setSpeed] = useState(50);
          const [isSimulating, setIsSimulating] = useState(false);
          const [progress, setProgress] = useState(0);
          const [stayStats, setStayStats] = useState<Stats>({ wins: 0, losses: 0 });
          const [switchStats, setSwitchStats] = useState<Stats>({ wins: 0, losses: 0 });
          const [animationData, setAnimationData] = useState<string[]>([]);
          
          const simulationStopped = useRef(false);

          // --- Manual Simulator Logic ---
          const resetManualGame = useCallback(() => {
            setDoors(setupDoors());
            setGameState('initial');
            setMessage(`${numberOfDoors}Í∞úÏùò Î¨∏ Ï§ë ÌïòÎÇòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.`);
          }, [setupDoors, numberOfDoors]);

          useEffect(() => {
              resetManualGame();
          }, [resetManualGame]);

          const handleDoorClick = (clickedIndex: number) => {
            if (gameState === 'finished' || gameState === 'picked') {
              return;
            }
          
            if (gameState === 'initial') {
              const newDoors = [...doors];
              newDoors[clickedIndex].isSelected = true;
              setDoors(newDoors);
              setGameState('picked');
          
              setTimeout(() => {
                setDoors(currentDoors => {
                  const hostOpenableDoors = currentDoors.reduce<number[]>((acc, door, index) => {
                    if (!door.isSelected && !door.hasPrize) {
                      acc.push(index);
                    }
                    return acc;
                  }, []);
          
                  const hostOpenIndex = hostOpenableDoors[Math.floor(Math.random() * hostOpenableDoors.length)];
                  
                  return currentDoors.map((door, index) => ({
                    ...door,
                    isOpen: index === hostOpenIndex,
                  }));
                });
                
                setGameState('revealed');
                setMessage('ÏÑ†ÌÉùÏùÑ Ïú†ÏßÄÌïòÎ†§Î©¥ ÏõêÎûò Î¨∏ÏùÑ, Î∞îÍæ∏Î†§Î©¥ Îã§Î•∏ Îã´Ìûå Î¨∏ÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî.');
              }, 1000);
              return;
            }
          
            if (gameState === 'revealed') {
              if (doors[clickedIndex].isOpen) {
                return;
              }
          
              const initialChoiceIndex = doors.findIndex(d => d.isSelected);
              const switched = clickedIndex !== initialChoiceIndex;
              const hasWon = doors[clickedIndex].hasPrize;
          
              setManualStats(prev => ({
                ...prev,
                total: prev.total + 1,
                stayWins: (!switched && hasWon) ? prev.stayWins + 1 : prev.stayWins,
                switchWins: (switched && hasWon) ? prev.switchWins + 1 : prev.switchWins,
              }));
          
              if (hasWon) {
                setMessage(switched ? 'Î∞îÍøîÏÑú Ïù¥Í≤ºÏäµÎãàÎã§!' : 'Ïú†ÏßÄÌï¥ÏÑú Ïù¥Í≤ºÏäµÎãàÎã§!');
              } else {
                setMessage(switched ? 'Î∞îÍøîÏÑú Ï°åÏäµÎãàÎã§.' : 'Ïú†ÏßÄÌï¥ÏÑú Ï°åÏäµÎãàÎã§.');
              }
          
              setDoors(currentDoors =>
                currentDoors.map((door, index) => ({
                  ...door,
                  isOpen: true,
                  isSelected: index === clickedIndex,
                }))
              );
              setGameState('finished');
            }
          };

          // --- Auto Simulator Logic ---
          const runSimulation = useCallback(async () => {
            setIsSimulating(true);
            simulationStopped.current = false;
            let localStayWins = 0;
            let localSwitchWins = 0;
            setStayStats({ wins: 0, losses: 0 });
            setSwitchStats({ wins: 0, losses: 0 });
            setProgress(0);
            setAnimationData([]);

            const delay = Math.max(0, 100 - speed);

            for (let i = 1; i <= simulations; i++) {
                if (simulationStopped.current) break;
                
                const currentDoors = Array(numberOfDoors).fill(false);
                let prizesPlaced = 0;
                while(prizesPlaced < numberOfPrizes){
                    const pos = Math.floor(Math.random() * numberOfDoors);
                    if(!currentDoors[pos]){
                        currentDoors[pos] = true;
                        prizesPlaced++;
                    }
                }
                const playerChoice = Math.floor(Math.random() * numberOfDoors);

                if (currentDoors[playerChoice]) {
                    localStayWins++;
                }

                const initialPickHasPrize = currentDoors[playerChoice];
                if (!initialPickHasPrize) {
                    const otherDoors = Array.from({length: numberOfDoors}, (_, k) => k).filter(k => k !== playerChoice);
                    const hostOpenable = otherDoors.filter(k => !currentDoors[k]);
                    const hostOpened = hostOpenable[Math.floor(Math.random() * hostOpenable.length)];
                    const switchable = otherDoors.filter(k => k !== hostOpened);
                    const switchChoice = switchable[Math.floor(Math.random() * switchable.length)];
                    if (currentDoors[switchChoice]) {
                        localSwitchWins++;
                    }
                }

                setStayStats({ wins: localStayWins, losses: i - localStayWins });
                setSwitchStats({ wins: localSwitchWins, losses: i - localSwitchWins });


                if (i % Math.ceil(simulations / 300) === 0) {
                    const lastStayResult = currentDoors[playerChoice] ? 'win' : 'loss';
                    setAnimationData(prevData => [...prevData.slice(-299), lastStayResult]);
                }

                if (i % Math.ceil(simulations / 100) === 0) {
                    setProgress((i / simulations) * 100);
                    if (delay > 0) {
                      await sleep(delay);
                    }
                }
            }
            setProgress(100);
            setIsSimulating(false);
          }, [simulations, speed, numberOfDoors, numberOfPrizes]);

          const handleStopSimulation = () => {
            simulationStopped.current = true;
            setIsSimulating(false);
          };

          const stayWinRate = stayStats.wins + stayStats.losses > 0 ? ((stayStats.wins / (stayStats.wins + stayStats.losses)) * 100).toFixed(1) : '0.0';
          const switchWinRate = switchStats.wins + switchStats.losses > 0 ? ((switchStats.wins / (switchStats.wins + switchStats.losses)) * 100).toFixed(1) : '0.0';

          return (
            <>
              <div className="section-card">
                <h2>ÏàòÎèô ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</h2>
                <div className="doors-container">
                  {doors.map((door, index) => (
                    <Door key={index} door={door} doorNumber={index + 1} onClick={() => handleDoorClick(index)} />
                  ))}
                </div>
                <p className="game-message">{message}</p>
                <div className="manual-controls">
                  {gameState === 'finished' && <button onClick={resetManualGame}>ÏÉà Í≤åÏûÑ</button>}
                </div>
                <div className="manual-stats">
                  <p>Ï¥ù Í≤åÏûÑ: {manualStats.total}</p>
                  <p>Ïú†ÏßÄÌï¥ÏÑú Ïù¥Í∏¥ ÌöüÏàò: {manualStats.stayWins}</p>
                  <p>Î∞îÍøîÏÑú Ïù¥Í∏¥ ÌöüÏàò: {manualStats.switchWins}</p>
                </div>
              </div>

              <hr />

              <div className="section-card">
                <h2>ÏûêÎèô ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</h2>
                <div className="config-panel">
                  <div className="config-item">
                    <label htmlFor="simulations">ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌöüÏàò</label>
                    <input
                      id="simulations"
                      type="number"
                      value={simulations}
                      onChange={(e) => setSimulations(Math.max(1, parseInt(e.target.value) || 1))}
                      disabled={isSimulating}
                    />
                  </div>
                  <div className="config-item wide">
                    <label htmlFor="speed">Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÜçÎèÑ (Îπ†Î•ºÏàòÎ°ù ÎîúÎ†àÏù¥ Ï†ÅÏùå): {speed}</label>
                    <input
                      id="speed"
                      type="range"
                      min="0"
                      max="100"
                      value={speed}
                      onChange={(e) => setSpeed(parseInt(e.target.value))}
                      disabled={isSimulating}
                    />
                  </div>
                </div>
                
                <div className="simulation-controls">
                    {!isSimulating ? (
                         <button onClick={runSimulation} disabled={isSimulating}>ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏãúÏûë</button>
                    ) : (
                         <button onClick={handleStopSimulation} className="stop-button">ÏãúÎÆ¨Î†àÏù¥ÏÖò Ï§ëÏßÄ</button>
                    )}
                </div>

                {isSimulating && <progress value={progress} max="100"></progress>}
                
                <div className="animation-grid">
                    {animationData.map((result, i) => <div key={i} className={`anim-door ${result}`}></div>)}
                </div>

                <div className="stats-container">
                  <div className="stats-box">
                    <h3>Ïú†ÏßÄ Ï†ÑÎûµ</h3>
                    <p>ÏäπÎ¶¨: {stayStats.wins.toLocaleString()}</p>
                    <p>Ìå®Î∞∞: {stayStats.losses.toLocaleString()}</p>
                    <p>ÏäπÎ•†: <span className="win">{stayWinRate}%</span></p>
                  </div>
                  <div className="stats-box">
                    <h3>Î∞îÍæ∏Í∏∞ Ï†ÑÎûµ</h3>
                    <p>ÏäπÎ¶¨: {switchStats.wins.toLocaleString()}</p>
                    <p>Ìå®Î∞∞: {switchStats.losses.toLocaleString()}</p>
                    <p>ÏäπÎ•†: <span className="win">{switchWinRate}%</span></p>
                  </div>
                </div>
              </div>
            </>
          );
        };


        const App: React.FC = () => {
            const [config, setConfig] = useState<SimulatorConfig>({ numberOfDoors: 3, numberOfPrizes: 1 });
            const [tempConfig, setTempConfig] = useState({
                doors: config.numberOfDoors.toString(),
                prizes: config.numberOfPrizes.toString(),
            });
            const [error, setError] = useState('');

            const handleApplyConfig = () => {
                const doorCount = parseInt(tempConfig.doors, 10);
                const prizeCount = parseInt(tempConfig.prizes, 10);

                const validate = () => {
                    if (isNaN(doorCount) || isNaN(prizeCount)) return 'Ïú†Ìö®Ìïú Ïà´ÏûêÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.';
                    if (doorCount < 3) return 'Î¨∏Ïùò Í∞úÏàòÎäî 3Í∞ú Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.';
                    if (prizeCount < 1) return 'ÏÉÅÌíàÏùò Í∞úÏàòÎäî 1Í∞ú Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.';
                    if (prizeCount >= doorCount) return 'ÏÉÅÌíàÏùò Í∞úÏàòÎäî Î¨∏ Í∞úÏàòÎ≥¥Îã§ Ï†ÅÏñ¥Ïïº Ìï©ÎãàÎã§.';
                    if (doorCount - prizeCount < 2) {
                        return 'Î∞îÍøÄ Ïàò ÏûàÎäî ÏÑ†ÌÉùÏßÄÎ•º ÎÇ®Í∏∞Î†§Î©¥, (Î¨∏Ïùò Í∞úÏàò - ÏÉÅÌíàÏùò Í∞úÏàò)Îäî 2 Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.';
                    }
                    return '';
                };

                const errorMessage = validate();
                if (errorMessage) {
                    setError(errorMessage);
                    return;
                }

                setError('');
                setConfig({ numberOfDoors: doorCount, numberOfPrizes: prizeCount });
            };

            return (
                <div id="app">
                    <h1>Ï°∞Í±¥Î∂ÄÌôïÎ•† ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</h1>

                    <div className="section-card settings-panel">
                      <h2>ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ ÏÑ§Ï†ï</h2>
                      <p>ÏãúÎÆ¨Î†àÏù¥ÏÖòÏóê ÏÇ¨Ïö©Ìï† Î¨∏Í≥º ÏÉÅÌíàÏùò Í∞úÏàòÎ•º ÏÑ§Ï†ïÌïòÏÑ∏Ïöî.</p>
                      <div className="config-panel">
                        <div className="config-item">
                          <label htmlFor="door-count">Î¨∏Ïùò Í∞úÏàò</label>
                          <input
                            id="door-count"
                            type="text" 
                            inputMode="numeric"
                            pattern="[0-9]*"
                            value={tempConfig.doors}
                            onChange={(e) => setTempConfig({ ...tempConfig, doors: e.target.value })}
                          />
                        </div>
                        <div className="config-item">
                          <label htmlFor="prize-count">ÏÉÅÌíàÏùò Í∞úÏàò</label>
                          <input
                            id="prize-count"
                            type="text"
                            inputMode="numeric"
                            pattern="[0-9]*"
                            value={tempConfig.prizes}
                            onChange={(e) => setTempConfig({ ...tempConfig, prizes: e.target.value })}
                          />
                        </div>
                      </div>
                      {error && <p className="error-message">{error}</p>}
                      <button onClick={handleApplyConfig} className="apply-settings-button">
                        ÏÑ§Ï†ï Ï†ÅÏö© & ÏãúÎÆ¨Î†àÏù¥ÏÖò Ï¥àÍ∏∞Ìôî
                      </button>
                    </div>

                    <Simulator key={JSON.stringify(config)} config={config} />
                </div>
            );
        };


        const container = document.getElementById('root');
        if (container) {
          const root = createRoot(container);
          root.render(<App />);
        }
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
